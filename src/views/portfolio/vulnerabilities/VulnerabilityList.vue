<template>
  <div class="animated fadeIn" v-permission="'VIEW_PORTFOLIO'">
    <portfolio-widget-row :fetch="true" />
    <div id="vulnerabilitiesToolbar" class="bs-table-custom-toolbar">
      <b-button size="md" variant="outline-primary" v-b-modal.vulnerabilityCreateVulnerabilityModal v-permission="PERMISSIONS.VULNERABILITY_MANAGEMENT">
        <span class="fa fa-plus"></span> {{ $t('message.create_vulnerability') }}
      </b-button>
      <b-button v-permission="'ACCESS_MANAGEMENT'" id="download-kev-report-button" size="md" variant="outline-primary"
                @click="downloadFullKevReport()"
                v-permission:or="[PERMISSIONS.VIEW_VULNERABILITY, PERMISSIONS.VULNERABILITY_ANALYSIS]">
          <span class="fa fa-download"></span> {{ $t('message.download_kev_report') }}
        </b-button>
    </div>
    <bootstrap-table
      ref="table"
      :columns="columns"
      :data="data"
      :options="options"
      @on-load-success="onLoadSuccess"
    >
    </bootstrap-table>
    <vulnerability-create-vulnerability-modal
      v-on:refreshTable="refreshTable"
    />
  </div>
</template>

<script>
  import { loadUserPreferencesForBootstrapTable } from "@/shared/utils";
import $ from "jquery";
import xssFilters from "xss-filters";
import permissionsMixin from "../../../mixins/permissionsMixin";
import routerMixin from "../../../mixins/routerMixin";
import common from "../../../shared/common";
import PortfolioWidgetRow from "../../dashboard/PortfolioWidgetRow";
import VulnerabilityCreateVulnerabilityModal from "./VulnerabilityCreateVulnerabilityModal";
import * as XLSX from 'xlsx';
import { TEAM_ADMIN } from "../../../shared/permissions";

  export default {
    mixins: [permissionsMixin, routerMixin],
    components: {
      VulnerabilityCreateVulnerabilityModal,
      PortfolioWidgetRow
    },
    methods: {
      apiUrl: function () {
        return `${this.$api.BASE_URL}/${this.$api.URL_VULNERABILITY}`;
      },
      refreshTable: function() {
        this.$refs.table.refresh({
          url: this.apiUrl(),
          pageNumber: 1,
          silent: true
        });
      },
      initializeTooltips: function () {
        $('[data-toggle="tooltip"]').tooltip();
      },
      onLoadSuccess: function () {
        loadUserPreferencesForBootstrapTable(this, "VulnerabilityList", this.$refs.table.columns);
      },

      // Download KEV report for all projects in excel format
      downloadFullKevReport: async function () {
        let kevReport = await this.getVulnerabilitiesInKev();

        let book = this.createExcelBook();
        book = this.addExcelSheet(kevReport, book, "KEV Report");

        this.downloadExcelBook(book, "Complete KEV Report"); 
      },
      // Return the KEV catalog (CISA)
      getKevCatalog: async function () {
        let url = `${this.$api.BASE_URL}/kev`; // reverse proxy
        return this.axios.request({
          url: url,
          method: 'get'
        });
      },
      // Returns projects affected by a specific vulnerability
      projectsAffectedByVulnerability: async function (vulnUUID) {
        let url = `${this.$api.BASE_URL}/${this.$api.URL_VULNERABILITY}/source/NVD/vuln/${vulnUUID}/projects`;
        return this.axios.request({
          url: url,
          method: 'get'
        }).then((response) => {
          return response.data;
        }).catch(error => {
          console.log("Vulnerability not found");
          return [];
        });
      },
      // Returns projects for a specific team
      getProjects: async function (teamUUID) {
        let url = `${this.$api.BASE_URL}/${this.$api.URL_ACL_TEAM}/${teamUUID}`;
        return this.axios.request({
          url: url,
          method: 'get'
        }).then((response) => {
          return response.data;
        });
      },
      // Returns all teams
      getTeams: async function () {
        let url = `${this.$api.BASE_URL}/${this.$api.URL_TEAM}`;
        return this.axios.request({
          url: url,
          method: 'get'
        }).then((response) => {
          return response.data;
        });
      },
      // Return project's KEV vulnerabilities in excel format
      getVulnerabilitiesInKev: async function () {
        //  Get all KEV vulnerabilities & teams
        let vulnerabilities = (await this.getKevCatalog()).data.vulnerabilities;
        let allTeams = await this.getTeams();

        // Map each project to it's team - key should be uuid of the project, value is the team name
        const projectToTeam = new Map();

        for(let i = 0; i < allTeams.length; i++){
          // Not including Administrator projects (they have access to all projects)
          if(allTeams[i].name !== "Administrators"){
            let teamProjects = await this.getProjects(allTeams[i].uuid);
            for(let j = 0; j < teamProjects.length; j++){
              projectToTeam.set(teamProjects[j].uuid, allTeams[i].name);
            }
          }
        }

        // Excel format
        let dataToExport = [["Team Affected", "Project Affected", "CVE ID", "Vulnerability Name", "Vendor Project", "Product", 
                    "Description", "Required Action", "Known Ransomeware Campaign Use", 
                    "Date Added", "Due Date", "Notes"]];

        // Loop through each vulnerability in the KEV catalog & get all projects it affects
        for(let i = 0; i < vulnerabilities.length; i++){ 
          let affectedProjects = await this.projectsAffectedByVulnerability(vulnerabilities[i].cveID);

          // For each affected project, check which team it belongs to & add it to the excel sheet
          for(let j = 0; j < affectedProjects.length; j++){ 
            let teamName = projectToTeam.get(affectedProjects[j].uuid) || "Administrators"            
            let projectDetails = affectedProjects[j].name + " " + (affectedProjects[j].version || "")

            let dataRow = [teamName, projectDetails, vulnerabilities[i].cveID, vulnerabilities[i].vulnerabilityName, vulnerabilities[i].vendorProject,
                          vulnerabilities[i].product, vulnerabilities[i].shortDescription, vulnerabilities[i].requiredAction,
                          vulnerabilities[i].knownRansomwareCampaignUse, vulnerabilities[i].dateAdded, 
                          vulnerabilities[i].dueDate, vulnerabilities[i].notes];
            dataToExport.push(dataRow);
          }
        }
        return dataToExport;
      },
      // Return project's KEV vulnerabilities in excel format
      // getVulnerabilitiesInKev2: async function () {
      //   let vulnerabilities = (await this.getKevCatalog()).data.vulnerabilities;
      //   let allTeams = await this.getTeams()
      //   let allTeamProjects = []

      //   for(let i = 0; i < allTeams.length; i++){ 
      //     // Do not include Administrator projects (they have access to everything)
      //     if(allTeams[i].name !== "Administrators"){
      //       let teamProjects = await this.getProjects(allTeams[i].uuid)    
      //       console.log(teamProjects)
      //       if(teamProjects.length > 0){
      //         allTeamProjects.push( {[allTeams[i].name]: teamProjects
      //         })
      //       }
      //     }
      //   }

      //   // Excel format
      //   let dataToExport = [["Affected Projects", "CVE ID", "Vulnerability Name", "Vendor Project", "Product", 
      //                       "Description", "Required Action", "Known Ransomeware Campaign Use", 
      //                       "Date Added", "Due Date", "Notes"]];


      //   console.log("all team projects", allTeamProjects)

      //   // Loop through each vulnerability in the KEV catalog & get all projects it affects
      //   for(let i = 0; i < vulnerabilities.length; i++){ 
      //     let projects = await this.projectsAffectedByVulnerability(vulnerabilities[i].cveID);
      //     let formattedProjects = "";

      //     // For each affected project, check which team it belongs to
      //     for(let j = 0; j < projects.length; j++){ 
      //       let teamName = "Administrators"
      //       // Look though each project, to find the matching project & team ???
      //       for(let k = 0; k < allTeamProjects.length; k++){
      //         for (let [team, teamProjects] of Object.entries(allTeamProjects[k])) {
      //           for(let l = 0; l < teamProjects.length; l++){
      //             if(teamProjects[l].uuid == projects[j].uuid){
      //               teamName = team
      //             }
      //           }
      //         }
      //       }
      //       formattedProjects += projects[j].name + ": " + projects[j].version + "   \n"
      //     }

      //     // If this KEV vulnerability affects a project, create an excel row of data with KEV info
      //     if(projects != undefined && projects.length > 0){
      //       let dataRow = [teamName, formattedProjects, vulnerabilities[i].cveID, vulnerabilities[i].vulnerabilityName, vulnerabilities[i].vendorProject,
      //                     vulnerabilities[i].product, vulnerabilities[i].shortDescription, vulnerabilities[i].requiredAction,
      //                     vulnerabilities[i].knownRansomwareCampaignUse, vulnerabilities[i].dateAdded, 
      //                     vulnerabilities[i].dueDate, vulnerabilities[i].notes];
      //       dataToExport.push(dataRow);
      //     }
      //   }
      //   return dataToExport;
      // },

      // Create a new excel workbook
      createExcelBook: function() {
        return XLSX.utils.book_new();
      },
      // Add a new excel sheet to an existing workbook
      addExcelSheet: function (data, book, sheetName) {
        let sheet = XLSX.utils.aoa_to_sheet(data);
        book.SheetNames.push(sheetName);
        book.Sheets[sheetName] = sheet;
        return book;
      },
      // Download an excel workbook
      downloadExcelBook: function (book, reportType) {
        XLSX.writeFile(book, reportType+".xlsx");
      }
    },
    data() {
      return {
        columns: [
          {
            title: this.$t('message.name'),
            field: "vulnId",
            sortable: true,
            formatter(value, row, index) {
              let url = xssFilters.uriInUnQuotedAttr("../vulnerabilities/" + row.source + "/" + value);
              return common.formatSourceLabel(row.source) + ` <a href="${url}">${xssFilters.inHTMLData(value)}</a>`;
            }
          },
          {
            title: this.$t('message.aliases'),
            field: "aliases",
            visible: false,
            formatter(value, row, index) {
              if (typeof value !== 'undefined') {
                let label = "";
                const aliases = common.resolveVulnAliases(value);
                for (let i=0; i<aliases.length; i++) {
                  let alias = aliases[i];
                  let url = xssFilters.uriInUnQuotedAttr("../vulnerabilities/" + alias.source + "/" + alias.vulnId);
                  label += common.formatSourceLabel(alias.source) + ` <a href="${url}">${xssFilters.inHTMLData(alias.vulnId)}</a>`
                  if (i < aliases.length-1) label += "<br/><br/>"
                }
                return label;
              }
            }
          },
          {
            title: this.$t('message.published'),
            field: "published",
            sortable: true,
            formatter(value, row, index) {
              if (typeof value !== 'undefined') {
                return common.formatTimestamp(value);
              }
            }
          },
          {
            title: this.$t('message.cwe'),
            field: 'cwes',
            sortable: false,
            formatter(value, row, index) {
              if (typeof value !== 'undefined') {
                let s = '';
                for (let i = 0; i < value.length; i++) {
                  let cwe = value[i];
                  if (i > 0) {
                    s += ',&nbsp;&nbsp;&nbsp;';
                  }
                  s += `CWE-${cwe.cweId}`;
                }
                return s;
              }
            },
          },
          {
            title: this.$t('message.projects'),
            field: 'affectedActiveProjectCount',
            class: 'tight',
            sortable: false,
          },
          {
            title: this.$t('message.severity'),
            field: 'severity',
            sortable: false,
            formatter(value, row, index) {
              if (typeof value !== 'undefined') {
                return common.formatSeverityLabel(value);
              }
            },
          },
        ],
      data: [],
      options: {
        onPostBody: this.initializeTooltips,
        search: true,
        showColumns: true,
        showRefresh: true,
        pagination: true,
        silentSort: false,
        sidePagination: 'server',
        queryParamsType: 'pageSize',
        pageList: '[10, 25, 50, 100]',
        pageSize:
          localStorage &&
          localStorage.getItem('VulnerabilityListPageSize') !== null
            ? Number(localStorage.getItem('VulnerabilityListPageSize'))
            : 10,
        sortName:
          localStorage &&
          localStorage.getItem('VulnerabilityListSortName') !== null
            ? localStorage.getItem('VulnerabilityListSortName')
            : undefined,
        sortOrder:
          localStorage &&
          localStorage.getItem('VulnerabilityListSortOrder') !== null
            ? localStorage.getItem('VulnerabilityListSortOrder')
            : undefined,
        searchText: this.$route.query.searchText
          ? this.$route.query.searchText
          : '',
        icons: {
          refresh: 'fa-refresh',
        },
        toolbar: '#vulnerabilitiesToolbar',
        responseHandler: function (res, xhr) {
          res.total = xhr.getResponseHeader('X-Total-Count');
          return res;
        },
        url: this.apiUrl(),
        onPageChange: (number, size) => {
          if (localStorage) {
            localStorage.setItem('VulnerabilityListPageSize', size.toString());
          }
        },
        onColumnSwitch: (field, checked) => {
          if (localStorage) {
            localStorage.setItem(
              'VulnerabilityListShow' + common.capitalize(field),
              checked.toString(),
            );
          }
        },
        onSort: (name, order) => {
          if (localStorage) {
            localStorage.setItem('VulnerabilityListSortName', name);
            localStorage.setItem('VulnerabilityListSortOrder', order);
          }
        },
        onSearch: (text) => {
          this.setSearchTextQuery(text);
        },
      },
    };
  },
};
</script>
